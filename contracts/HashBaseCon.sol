pragma solidity >=0.4.22 <0.7.0;


import "./HashOperateLib.sol";
import "openzeppelin-solidity/contracts/ownership/Ownable.sol";
import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "../solidity-stringutils/src/strings.sol";


/**
 * This contract will take charge of submitting base hash value to blockchain
 * it will be inherited by other hash operating contracts
 */
contract DRCHashBase is Ownable {
  //import the HashOperateLib for contract
  using HashOperateLib for HashOperateLib.Info;
  using StringUtils for string;
  using strings for *;
  using SafeMath for uint256;

  HashOperateLib.Info internal hashInfoLib;
  string public memo;
  mapping(string => string) internal txHashInfo; // hash => txHash
  mapping(string => string) internal insertedHashInfo; // txHash => hash


  /**
   * @dev set the memo to describe the objective of the contract
   */
  function setMemo(string memory _memoStr) public onlyOwner returns(bool) {
    memo = _memoStr;
    return true;
  }  

  /**
   * @dev add Tx hash for the hash string uploaded to blockchain
   * @param _hash is input value of hash
   * @param _txHash is the Tx hash value generated by action of inserting hash
   * @return bool,true is successful and false is failed
   */
  function addTxIdForOnchainData(string memory _hash, string memory _txHash) 
    public 
    onlyOwner 
    returns (bool) 
  {
    require(!_hash.equal(""));

    if (!hashInfoLib.isHashExisted(_hash)) {
      return false;
    } else {
      txHashInfo[_hash] = _txHash;
      insertedHashInfo[_txHash] = _hash;
      return true;
    }
  }

  /**
   * @dev get Tx hash for the hash string uploaded to blockchain
   * @param _hash is input value of hash
   * @return is the Tx hash value generated by action of inserting hash
   */
  function getTxIdByHash(string memory _hash) public view returns (string memory) {
    require(!_hash.equal(""));
    return txHashInfo[_hash];
  }

  /**
   * @dev get inserted hash string by the Tx hash
   * @param _txHash is input value of Tx hash
   * @return is the hash string corresponding to the Tx hash
   */
  function getHashByTxId(string memory _txHash) public view returns (string memory) {
    require(!_txHash.equal(""));
    return insertedHashInfo[_txHash];
  }

  /**
   * @dev get a group of Tx hashs for the hash strings uploaded to blockchain
   * @param _indices is array of the index of the Tx hash group
   * @return is the Tx hash value generated by action of inserting hash
   */
  function getInsertedHashGroup(uint[] memory _indices) public view returns (bytes memory) {
    uint len = _indices.length;

    strings.slice[] memory hashSlices = new strings.slice[](len);
    for(uint i = 0; i < len; i = i.add(1)) {
      string memory tmpHashStr = hashInfoLib.getHashByInd(_indices[i]);
      hashSlices[i] = tmpHashStr.toSlice();
    }
    string memory hashStrs = ",".toSlice().join(hashSlices);

    return (abi.encode(hashStrs));
  }

  /**
   * @dev insertHash,insert hash into contract with bytes data
	 * @param _hash is input value of hash
   * @param _uploadedData is the data being uploaded with hash value
	 * @return bool,true is successful and false is failed
   */
  function insertHash(string memory _hash, bytes memory _uploadedData) public returns(bool);

  /**
	 * @dev selectHash,select hash from contract
	 * @param _hash is input value of hash
	 * @return true/false,saver,uploadedData,save time
	 */
  function selectHash(string memory _hash) public view returns (bool, address, bytes memory, uint256, string memory);
    
	/**
	 * @dev deleteHash,delete hash into contract
	 * @param _hash is input value of hash
	 * @return bool,true is successful and false is failed
	 */
  function deleteHash(string memory _hash) public returns (bool);

}