pragma solidity >=0.4.22 <0.7.0;


import "./HashOperateLib.sol";
import "openzeppelin-solidity/contracts/ownership/Ownable.sol";
import "../solidity-lib/utils/StringUtils.sol";


/**
 * This contract will take charge of submitting base hash value to blockchain
 * it will be inherited by other hash operating contracts
 */
contract DRCHashBase is Ownable {
  //import the HashOperateLib for contract
  using HashOperateLib for HashOperateLib.Info;
  using StringUtils for string;

  HashOperateLib.Info internal hashInfo;
  string public memo;
  mapping(string => string) private txHashInfo;
  mapping(string => string) private insertedHashInfo;

  constructor() internal {
  }

  /**
   * @dev set the memo to describe the objective of the contract
   */
  function setMemo(string _memoStr) public onlyOwner returns(bool) {
    memo = _memoStr;
    return true;
  }  

  /**
   * @dev add Tx hash for the hash string uploaded to blockchain
   * @param _hash is input value of hash
   * @param _txHash is the Tx hash value generated by action of inserting hash
   * @return bool,true is successful and false is failed
   */
  function addTxIdForOnchainData(string _hash, string _txHash) public onlyOwner returns (bool) 
  {
    require(!_hash.equal(""));
    if (hashInfo[_hash].saveTime <= 0) {
      return false;
    } else {
      txHashInfo[_hash] = _txHash;
      insertedHashInfo[_txHash] = _hash;
      return true;
    }
  }

  /**
   * @dev get Tx hash for the hash string uploaded to blockchain
   * @param _hash is input value of hash
   * @return is the Tx hash value generated by action of inserting hash
   */
  function getTxIdByHash(string _hash) public view returns (string) {
    require(!_hash.equal(""));
    return txHashInfo[_hash];
  }

  /**
   * @dev get inserted hash string by the Tx hash
   * @param _txHash is input value of Tx hash
   * @return is the hash string corresponding to the Tx hash
   */
  function getHashByTxId(string _txHash) public view returns (string) {
    require(!_txHash.equal(""));
    return insertedHashInfo[_txHash];
  }

  /**
   * @dev get Tx hash for the hash string uploaded to blockchain
   * @param _hash is input value of hash
   * @return is the Tx hash value generated by action of inserting hash
   */
  function getInsertedHashGroup(uint[] _indices, uint8 _num) public view returns (bytes) {
    require(_num > 0 && _indices.length == _num);

    string[] memory hashStrs = new string[128];
    for (int i = 0; i < _num; i++) {
      hashStrs[i] = hashInfo.getHashByInd(_indices[i]);
    }

    return (abi.encode(hashStrs));
  }

  /**
   * @dev insertHash,insert hash into contract with bytes data
	 * @param _hash is input value of hash
   * @param _uploadedData is the data being uploaded with hash value
	 * @return bool,true is successful and false is failed
   */
  function insertHash(string _hash, bytes _uploadedData) public returns(bool);

  /**
	 * @dev selectHash,select hash from contract
	 * @param _hash is input value of hash
	 * @return true/false,saver,uploadedData,save time
	 */
  function selectHash(string _hash) public view returns (bool, address, bytes, uint256, string);
    
	/**
	 * @dev deleteHash,delete hash into contract
	 * @param _hash is input value of hash
	 * @return bool,true is successful and false is failed
	 */
  function deleteHash(string _hash) public returns (bool);

}